<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Paper Tiger: Packet subsystem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Paper Tiger
   </div>
   <div id="projectbrief">An open-source Terraria server written in C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Packet subsystem<div class="ingroups"><a class="el" href="group__paper-tiger.html">The Paper Tiger API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The packet subsystem provides a mechanism to read and write encoded Terraria messages to Terraria clients.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpacket.html">packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a Terraria message.  <a href="structpacket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpacket__handler.html">packet_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a packet handler in the packet handler table.  <a href="structpacket__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga10aa1174318b280e6772d66ef7ff010e"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga10aa1174318b280e6772d66ef7ff010e">packet_write_cb</a>) (<a class="el" href="group__talloc.html#ga8a521b1347c0e37b84eb942db8fa9beb">TALLOC_CTX</a> *context, const struct <a class="el" href="structpacket.html">packet</a> *<a class="el" href="structpacket.html">packet</a>, const struct <a class="el" href="structplayer.html">player</a> *<a class="el" href="structplayer.html">player</a>, uv_buf_t *buffer)</td></tr>
<tr class="memdesc:ga10aa1174318b280e6772d66ef7ff010e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call in order for the server to do something with a message that has been received from the client.  <a href="#ga10aa1174318b280e6772d66ef7ff010e">More...</a><br /></td></tr>
<tr class="separator:ga10aa1174318b280e6772d66ef7ff010e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60dc8d100ec60f5abb142f1f2253e6b2"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga60dc8d100ec60f5abb142f1f2253e6b2">packet_read_cb</a>) (struct <a class="el" href="structpacket.html">packet</a> *<a class="el" href="structpacket.html">packet</a>, const uv_buf_t *buffer)</td></tr>
<tr class="memdesc:ga60dc8d100ec60f5abb142f1f2253e6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call to translate a packet from a network buffer to a fully-qualified <code>struct packet</code>.  <a href="#ga60dc8d100ec60f5abb142f1f2253e6b2">More...</a><br /></td></tr>
<tr class="separator:ga60dc8d100ec60f5abb142f1f2253e6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d343d646c5c1e052d61561702a4bf3e"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9d343d646c5c1e052d61561702a4bf3e">packet_handle_cb</a>) (struct <a class="el" href="structplayer.html">player</a> *<a class="el" href="structplayer.html">player</a>, struct <a class="el" href="structpacket.html">packet</a> *<a class="el" href="structpacket.html">packet</a>)</td></tr>
<tr class="memdesc:ga9d343d646c5c1e052d61561702a4bf3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called when a message is to be handled by the server.  <a href="#ga9d343d646c5c1e052d61561702a4bf3e">More...</a><br /></td></tr>
<tr class="separator:ga9d343d646c5c1e052d61561702a4bf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae1a0e160a43c079e2d7962f47f58bf58"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpacket__handler.html">packet_handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae1a0e160a43c079e2d7962f47f58bf58">packet_handler_for_type</a> (uint8_t type)</td></tr>
<tr class="memdesc:gae1a0e160a43c079e2d7962f47f58bf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to the registered packet handler for the message type specified.  <a href="#gae1a0e160a43c079e2d7962f47f58bf58">More...</a><br /></td></tr>
<tr class="separator:gae1a0e160a43c079e2d7962f47f58bf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1eeb3e87dd58880b8845a81d790511a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac1eeb3e87dd58880b8845a81d790511a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>packet_write_header</b> (uint8_t type, uint16_t len, uv_buf_t *buf, int *pos)</td></tr>
<tr class="separator:gac1eeb3e87dd58880b8845a81d790511a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga369495736b1aa87c1a27a60fc9501d90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga369495736b1aa87c1a27a60fc9501d90"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>packet_read_header</b> (const uv_buf_t *buf, uint8_t *out_type, uint16_t *out_len)</td></tr>
<tr class="separator:ga369495736b1aa87c1a27a60fc9501d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae618365b8e6293ce17a773149a384fcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae618365b8e6293ce17a773149a384fcf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>packet_new</b> (<a class="el" href="group__talloc.html#ga8a521b1347c0e37b84eb942db8fa9beb">TALLOC_CTX</a> *ctx, struct <a class="el" href="structplayer.html">player</a> *<a class="el" href="structplayer.html">player</a>, const uv_buf_t *buf, struct <a class="el" href="structpacket.html">packet</a> **out_packet)</td></tr>
<tr class="separator:gae618365b8e6293ce17a773149a384fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga7b613bc0cf0d706a0c825dadfc6840d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7b613bc0cf0d706a0c825dadfc6840d2"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7b613bc0cf0d706a0c825dadfc6840d2">packet::len</a></td></tr>
<tr class="memdesc:ga7b613bc0cf0d706a0c825dadfc6840d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The packet length including the 3-byte message header, in bytes. <br /></td></tr>
<tr class="separator:ga7b613bc0cf0d706a0c825dadfc6840d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53b4fdec86403ff886583182dfae176e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga53b4fdec86403ff886583182dfae176e"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga53b4fdec86403ff886583182dfae176e">packet::type</a></td></tr>
<tr class="memdesc:ga53b4fdec86403ff886583182dfae176e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Terraria message type. <br /></td></tr>
<tr class="separator:ga53b4fdec86403ff886583182dfae176e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3115ffc58cc55bae08635ed965c4768"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3115ffc58cc55bae08635ed965c4768"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad3115ffc58cc55bae08635ed965c4768">packet::data</a></td></tr>
<tr class="memdesc:gad3115ffc58cc55bae08635ed965c4768"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the packet payload object that was deserialized using the <code>packet_read_cb</code> function inside the packet handler table. <br /></td></tr>
<tr class="separator:gad3115ffc58cc55bae08635ed965c4768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacda150a3844cee9928fc89d9c1e0204e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacda150a3844cee9928fc89d9c1e0204e"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>packet_handler::type</b></td></tr>
<tr class="separator:gacda150a3844cee9928fc89d9c1e0204e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043987d5914119b6cb9fd322cad1731c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga043987d5914119b6cb9fd322cad1731c"></a>
<a class="el" href="group__packet.html#ga60dc8d100ec60f5abb142f1f2253e6b2">packet_read_cb</a>&#160;</td><td class="memItemRight" valign="bottom"><b>packet_handler::read_func</b></td></tr>
<tr class="separator:ga043987d5914119b6cb9fd322cad1731c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b542606e8c009aa6da139d5a89ed58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga83b542606e8c009aa6da139d5a89ed58"></a>
<a class="el" href="group__packet.html#ga9d343d646c5c1e052d61561702a4bf3e">packet_handle_cb</a>&#160;</td><td class="memItemRight" valign="bottom"><b>packet_handler::handle_func</b></td></tr>
<tr class="separator:ga83b542606e8c009aa6da139d5a89ed58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b6b0734e245ed023ef11387ec04c66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54b6b0734e245ed023ef11387ec04c66"></a>
<a class="el" href="group__packet.html#ga10aa1174318b280e6772d66ef7ff010e">packet_write_cb</a>&#160;</td><td class="memItemRight" valign="bottom"><b>packet_handler::write_func</b></td></tr>
<tr class="separator:ga54b6b0734e245ed023ef11387ec04c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The packet subsystem provides a mechanism to read and write encoded Terraria messages to Terraria clients. </p>
<p>All Terraria messages have a header consisting of 3 bytes; the packet length as a 16-bit unsigned integer, and a single-byte message type specifier.</p>
<p>Terraria messages are all encoded into one packet structure (<code>struct packet</code>) which contains the header fields and a generic pointer (called <code>data</code>) which points to the structure containing the body of the message, decoded by the packet system by a call to the registered <b>Read</b> handler for that packet type.</p>
<p>Each packet has its own implementation in <code>src/packets</code> and are handled in an object-oriented manner. Packet implementations must implement any number of three functions in the packet handler table in <code>src/packets.c</code>:</p>
<table class="doxtable">
<tr>
<th>Function </th><th>Prototype </th><th>Description  </th></tr>
<tr>
<td>Read </td><td><code>int (*packet_read_cb)(struct packet *packet, uv_buf_t *buf)</code> </td><td>Packet read functions are responsible for filling the body of the <code>struct packet</code> out once the header information has been parsed. Memory for the packet body must be <code>talloc</code>ated underneath the <code>struct packet</code> so it may be freed when the packet is released. At the return of this handler function, the <code>data</code> member of <code>struct packet</code> must point to a valid structure containing the contents of the packet body. </td></tr>
<tr>
<td>Write </td><td><code>int (*packet_write_cb)(TALLOC_CTX *context, const struct packet *packet, const struct player *player, uv_buf_t *buffer)</code> </td><td>Packet write functions are responsible for serializing the <code>struct packet</code> instance into a buffer for sending to a client. This function is responsible for allocating enough room in the uv_buf_t structure to accomodate the entire message which must be <code>talloc</code>ated underneath the context pointed to by <code>context</code>. </td></tr>
<tr>
<td>Handle </td><td><code>int (*packet_handle_cb)(struct player *player, struct packet *packet)</code> </td><td>Packet handle functions are called in order for the server to do something with a message that has been received from the client. Implement this function to do something with a packet once it has been received. <b>Note:</b> Do not directly free the structure in the handle functions, as they are destroyted automatically at the return of this function. </td></tr>
</table>
<p>Packet implementations may provide <code>new</code> constructor functions to aid creating of packets in order for them to be sent to clients via <code>server_send_packet</code>. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga9d343d646c5c1e052d61561702a4bf3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* packet_handle_cb) (struct <a class="el" href="structplayer.html">player</a> *<a class="el" href="structplayer.html">player</a>, struct <a class="el" href="structpacket.html">packet</a> *<a class="el" href="structpacket.html">packet</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called when a message is to be handled by the server. </p>
<p>This function gets called by the packet subsystem when it has a message for the server to process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">player</td><td>A pointer to the player who sent the message</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>A pointer to the message received from the player</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> if the packet handling succeeded, <code>&lt; 0</code> otherwise, or if the handler would like the server to fatally exit upon a condition. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60dc8d100ec60f5abb142f1f2253e6b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* packet_read_cb) (struct <a class="el" href="structpacket.html">packet</a> *<a class="el" href="structpacket.html">packet</a>, const uv_buf_t *buffer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to call to translate a packet from a network buffer to a fully-qualified <code>struct packet</code>. </p>
<p>Packet read functions are responsible for filling the body of the <code>struct packet</code> out once the header information has been parsed. Memory for the packet body must be <code>talloc</code>ated underneath the <code>struct packet</code> so it may be freed when the packet is released. At the return of this handler function, the <code>data</code> member of <code>struct packet</code> must point to a valid structure containing the contents of the packet body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>A pointer to a partially-allocated packet structure. The <code>len</code> and <code>type</code> members of this function are pre-filled</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to an allocated network buffer in which to deserialize the Terraria message from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> if the decoding was successful, <code>&lt; 0</code> otherwise.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is responsible for setting the <code>data</code> member of the packet structure pointed to by <em>packet</em>. All memory for the packets body must be <code>talloc</code>ated underneath the <em>packet</em> context so it may be freed when the packet is no longer required.</dd></dl>
<p>At the return of this function, the <code>data</code> member of the packet must point to a valid packet body, or <code>NULL</code> if the packet does not have a body. </p>

</div>
</div>
<a class="anchor" id="ga10aa1174318b280e6772d66ef7ff010e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* packet_write_cb) (<a class="el" href="group__talloc.html#ga8a521b1347c0e37b84eb942db8fa9beb">TALLOC_CTX</a> *context, const struct <a class="el" href="structpacket.html">packet</a> *<a class="el" href="structpacket.html">packet</a>, const struct <a class="el" href="structplayer.html">player</a> *<a class="el" href="structplayer.html">player</a>, uv_buf_t *buffer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to call in order for the server to do something with a message that has been received from the client. </p>
<p>Implement this function to do something with a packet once it has been received. <b>Note:</b> Do not directly free the structure in the handle functions, as they are destroyted automatically at the return of this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The talloc context object in which any buffer memory must be allocated underneath, so it may be freed when the packet is no longer in use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>An instance of the packet of the same type to have its contents serialized</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">player</td><td>A player who will receive the encoded message once it has been filled into the buffer for sending</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to an unallocated uv_buf_t structure. <b>The write handler is responsible for allocating the buffer structure and its buffers with enough room to contain the encoded packet</b>. The buffer will be freed when the talloc context pointed to by <em>context</em> is freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> if the encoding was successful, <code>&lt; 0</code> otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae1a0e160a43c079e2d7962f47f58bf58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpacket__handler.html">packet_handler</a>* packet_handler_for_type </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a pointer to the registered packet handler for the message type specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of message to retrieve the handler structure for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the packet handler if one owas found in the packet handler table if one was found by the message type, or NULL if one was not found or there was an error. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
