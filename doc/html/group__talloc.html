<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Paper Tiger: The talloc API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Paper Tiger
   </div>
   <div id="projectbrief">An open-source Terraria server written in C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">The talloc API</div>  </div>
</div><!--header-->
<div class="contents">

<p>talloc is a hierarchical, reference counted memory pool system with destructors.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__talloc__ref"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc__ref.html">The talloc reference function.</a></td></tr>
<tr class="memdesc:group__talloc__ref"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module contains the definitions around talloc references. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa1b665edcef3b29a36bdbaa5f95092be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1b665edcef3b29a36bdbaa5f95092be"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TALLOC_VERSION_MAJOR</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:gaa1b665edcef3b29a36bdbaa5f95092be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3028a11b933199eb0b332cd176e8253f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3028a11b933199eb0b332cd176e8253f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TALLOC_VERSION_MINOR</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga3028a11b933199eb0b332cd176e8253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aca6cf6b79367d4d8459566324ec078"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2aca6cf6b79367d4d8459566324ec078"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__TALLOC_STRING_LINE1__</b>(s)    &#160;&#160;&#160;#s</td></tr>
<tr class="separator:ga2aca6cf6b79367d4d8459566324ec078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0c050d4373e4d8b421a20230dc67095"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab0c050d4373e4d8b421a20230dc67095"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__TALLOC_STRING_LINE2__</b>(s)  &#160;&#160;&#160;__TALLOC_STRING_LINE1__(s)</td></tr>
<tr class="separator:gab0c050d4373e4d8b421a20230dc67095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga089300cc411713199beb2905ac62929a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga089300cc411713199beb2905ac62929a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__TALLOC_STRING_LINE3__</b>&#160;&#160;&#160;__TALLOC_STRING_LINE2__(__LINE__)</td></tr>
<tr class="separator:ga089300cc411713199beb2905ac62929a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2102830a39706812c27290bec32a9259"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2102830a39706812c27290bec32a9259"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__location__</b>&#160;&#160;&#160;__FILE__ &quot;:&quot; __TALLOC_STRING_LINE3__</td></tr>
<tr class="separator:ga2102830a39706812c27290bec32a9259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec69750b797d06c6dec94862d19736e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec69750b797d06c6dec94862d19736e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TALLOC_DEPRECATED</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gaec69750b797d06c6dec94862d19736e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf41a0a9441b1da20577215063408402f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf41a0a9441b1da20577215063408402f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRINTF_ATTRIBUTE</b>(a1,  a2)</td></tr>
<tr class="separator:gaf41a0a9441b1da20577215063408402f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe346eee9b905819ea950bda14456e14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe346eee9b905819ea950bda14456e14"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc</b>(ctx,  type)&#160;&#160;&#160;(type *)<a class="el" href="group__talloc.html#ga72dc3f21af6c125c71221860c5d9fd36">talloc_named_const</a>(ctx, sizeof(type), #type)</td></tr>
<tr class="separator:gafe346eee9b905819ea950bda14456e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4d90a81e4d1cde1b334007639aac861"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac4d90a81e4d1cde1b334007639aac861"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_free</b>(ctx)&#160;&#160;&#160;_talloc_free(ctx, __location__)</td></tr>
<tr class="separator:gac4d90a81e4d1cde1b334007639aac861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d04b1322f92d5583e72f67d864d49b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3d04b1322f92d5583e72f67d864d49b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_set_destructor</b>(ptr,  function)&#160;&#160;&#160;_talloc_set_destructor((ptr), (int (*)(void *))(function))</td></tr>
<tr class="separator:gad3d04b1322f92d5583e72f67d864d49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f276c1615178e82165da44b3b67221b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f276c1615178e82165da44b3b67221b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_TALLOC_TYPEOF</b>(ptr)&#160;&#160;&#160;void *</td></tr>
<tr class="separator:ga3f276c1615178e82165da44b3b67221b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c827f7b3f7e609e07a1eb22b78e3705"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c827f7b3f7e609e07a1eb22b78e3705"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_steal</b>(ctx,  ptr)&#160;&#160;&#160;(_TALLOC_TYPEOF(ptr))_talloc_steal_loc((ctx),(ptr), __location__)</td></tr>
<tr class="separator:ga6c827f7b3f7e609e07a1eb22b78e3705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa819720a073d6c24179d49f4db06b880"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa819720a073d6c24179d49f4db06b880"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_move</b>(ctx,  pptr)&#160;&#160;&#160;(_TALLOC_TYPEOF(*(pptr)))_talloc_move((ctx),(void *)(pptr))</td></tr>
<tr class="separator:gaa819720a073d6c24179d49f4db06b880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6b0d2b1ea5861ad0cdcb9ba44a27cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1e6b0d2b1ea5861ad0cdcb9ba44a27cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_size</b>(ctx,  size)&#160;&#160;&#160;<a class="el" href="group__talloc.html#ga72dc3f21af6c125c71221860c5d9fd36">talloc_named_const</a>(ctx, size, __location__)</td></tr>
<tr class="separator:ga1e6b0d2b1ea5861ad0cdcb9ba44a27cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga701fcfe911d22322568edb930746874e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga701fcfe911d22322568edb930746874e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_ptrtype</b>(ctx,  ptr)&#160;&#160;&#160;(_TALLOC_TYPEOF(ptr))talloc_size(ctx, sizeof(*(ptr)))</td></tr>
<tr class="separator:ga701fcfe911d22322568edb930746874e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb84ffe9387a259e0b1cf8245747f032"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb84ffe9387a259e0b1cf8245747f032"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_new</b>(ctx)&#160;&#160;&#160;<a class="el" href="group__talloc.html#ga72dc3f21af6c125c71221860c5d9fd36">talloc_named_const</a>(ctx, 0, &quot;talloc_new: &quot; __location__)</td></tr>
<tr class="separator:gadb84ffe9387a259e0b1cf8245747f032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8a378dcb3147841371c03e4dbb3cfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadc8a378dcb3147841371c03e4dbb3cfe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_zero</b>(ctx,  type)&#160;&#160;&#160;(type *)_talloc_zero(ctx, sizeof(type), #type)</td></tr>
<tr class="separator:gadc8a378dcb3147841371c03e4dbb3cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4463b5c9d6c20e4e9c42927aecfd3d7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4463b5c9d6c20e4e9c42927aecfd3d7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_zero_size</b>(ctx,  size)&#160;&#160;&#160;_talloc_zero(ctx, size, __location__)</td></tr>
<tr class="separator:ga4463b5c9d6c20e4e9c42927aecfd3d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ef753d2eabbd539e80ed92879ecbf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga95ef753d2eabbd539e80ed92879ecbf4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_memdup</b>(t,  p,  size)&#160;&#160;&#160;_talloc_memdup(t, p, size, __location__)</td></tr>
<tr class="separator:ga95ef753d2eabbd539e80ed92879ecbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga750c1ae3fea2c84670a2e4962f319b35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga750c1ae3fea2c84670a2e4962f319b35"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_set_type</b>(ptr,  type)&#160;&#160;&#160;<a class="el" href="group__talloc.html#ga204ed205d6b1524c46f12541d5eca686">talloc_set_name_const</a>(ptr, #type)</td></tr>
<tr class="separator:ga750c1ae3fea2c84670a2e4962f319b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf96938ad0d47dd54da843b4db8154dbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf96938ad0d47dd54da843b4db8154dbc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_get_type</b>(ptr,  type)&#160;&#160;&#160;(type *)<a class="el" href="group__talloc.html#ga1f4f10b2b41c13879fd30cdb30b50862">talloc_check_name</a>(ptr, #type)</td></tr>
<tr class="separator:gaf96938ad0d47dd54da843b4db8154dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d5dbe930855dad7e41b55812784892"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga67d5dbe930855dad7e41b55812784892"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_get_type_abort</b>(ptr,  type)&#160;&#160;&#160;(type *)_talloc_get_type_abort(ptr, #type, __location__)</td></tr>
<tr class="separator:ga67d5dbe930855dad7e41b55812784892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd0116a79837a6c02069aa849572875"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8fd0116a79837a6c02069aa849572875"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_find_parent_bytype</b>(ptr,  type)&#160;&#160;&#160;(type *)<a class="el" href="group__talloc.html#gaa5dee9fd4d8d4700f14ea4dd92cd4f14">talloc_find_parent_byname</a>(ptr, #type)</td></tr>
<tr class="separator:ga8fd0116a79837a6c02069aa849572875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7641a167abed37605421833eb5f92a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_pooled_object</b>(_ctx,  _type,  _num_subobjects,  _total_subobjects_size)</td></tr>
<tr class="separator:gac7641a167abed37605421833eb5f92a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3203a43d49423d064e1d889f6c584d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga2b3203a43d49423d064e1d889f6c584d">TALLOC_FREE</a>(ctx)&#160;&#160;&#160;do { talloc_free(ctx); ctx=NULL; } while(0)</td></tr>
<tr class="memdesc:ga2b3203a43d49423d064e1d889f6c584d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a talloc chunk and NULL out the pointer.  <a href="#ga2b3203a43d49423d064e1d889f6c584d">More...</a><br /></td></tr>
<tr class="separator:ga2b3203a43d49423d064e1d889f6c584d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8a521b1347c0e37b84eb942db8fa9beb"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga8a521b1347c0e37b84eb942db8fa9beb">TALLOC_CTX</a></td></tr>
<tr class="memdesc:ga8a521b1347c0e37b84eb942db8fa9beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a talloc parent type.  <a href="#ga8a521b1347c0e37b84eb942db8fa9beb">More...</a><br /></td></tr>
<tr class="separator:ga8a521b1347c0e37b84eb942db8fa9beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaec179ec7cec2f22979ed6ae8ead16ba3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec179ec7cec2f22979ed6ae8ead16ba3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_version_major</b> (void)</td></tr>
<tr class="separator:gaec179ec7cec2f22979ed6ae8ead16ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ffad371cc3a041d8c25b1350040dab4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6ffad371cc3a041d8c25b1350040dab4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>talloc_version_minor</b> (void)</td></tr>
<tr class="separator:ga6ffad371cc3a041d8c25b1350040dab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9166458454d5a321e9fab486b1984f31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9166458454d5a321e9fab486b1984f31"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>_talloc</b> (const void *context, size_t size)</td></tr>
<tr class="separator:ga9166458454d5a321e9fab486b1984f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f4a621ca5763f779d011d88b869bbeb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga4f4a621ca5763f779d011d88b869bbeb">talloc_init</a> (const char *fmt,...) PRINTF_ATTRIBUTE(1</td></tr>
<tr class="memdesc:ga4f4a621ca5763f779d011d88b869bbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new top level talloc context.  <a href="#ga4f4a621ca5763f779d011d88b869bbeb">More...</a><br /></td></tr>
<tr class="separator:ga4f4a621ca5763f779d011d88b869bbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd2cd2e00cf25ccfb4ed112b37128ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabbd2cd2e00cf25ccfb4ed112b37128ab"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_talloc_free</b> (void *ptr, const char *location)</td></tr>
<tr class="separator:gabbd2cd2e00cf25ccfb4ed112b37128ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939926bc6d0d87e1f223a993decb70e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga939926bc6d0d87e1f223a993decb70e9">talloc_free_children</a> (void *ptr)</td></tr>
<tr class="memdesc:ga939926bc6d0d87e1f223a993decb70e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a talloc chunk's children.  <a href="#ga939926bc6d0d87e1f223a993decb70e9">More...</a><br /></td></tr>
<tr class="separator:ga939926bc6d0d87e1f223a993decb70e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1727514444a8b582af5c71a105c2c109"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1727514444a8b582af5c71a105c2c109"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_talloc_set_destructor</b> (const void *ptr, int(*_destructor)(void *))</td></tr>
<tr class="separator:ga1727514444a8b582af5c71a105c2c109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa710048b3463fe968260882814428471"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa710048b3463fe968260882814428471"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>_talloc_steal_loc</b> (const void *new_ctx, const void *ptr, const char *location)</td></tr>
<tr class="separator:gaa710048b3463fe968260882814428471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75097bd7d060a95d42f76cf41bffa207"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga75097bd7d060a95d42f76cf41bffa207">talloc_set_name</a> (const void *ptr, const char *fmt,...) PRINTF_ATTRIBUTE(2</td></tr>
<tr class="memdesc:ga75097bd7d060a95d42f76cf41bffa207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a name to a talloc chunk.  <a href="#ga75097bd7d060a95d42f76cf41bffa207">More...</a><br /></td></tr>
<tr class="separator:ga75097bd7d060a95d42f76cf41bffa207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a91eb0e4c97eb636b8bbc3bcb5ec540"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a91eb0e4c97eb636b8bbc3bcb5ec540"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>_talloc_move</b> (const void *new_ctx, const void *pptr)</td></tr>
<tr class="separator:ga5a91eb0e4c97eb636b8bbc3bcb5ec540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga204ed205d6b1524c46f12541d5eca686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga204ed205d6b1524c46f12541d5eca686">talloc_set_name_const</a> (const void *ptr, const char *name)</td></tr>
<tr class="memdesc:ga204ed205d6b1524c46f12541d5eca686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a name to a talloc chunk.  <a href="#ga204ed205d6b1524c46f12541d5eca686">More...</a><br /></td></tr>
<tr class="separator:ga204ed205d6b1524c46f12541d5eca686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bd5a797d207c4e04799105c065c46be"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga8bd5a797d207c4e04799105c065c46be">talloc_named</a> (const void *context, size_t size, const char *fmt,...) PRINTF_ATTRIBUTE(3</td></tr>
<tr class="memdesc:ga8bd5a797d207c4e04799105c065c46be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a named talloc chunk.  <a href="#ga8bd5a797d207c4e04799105c065c46be">More...</a><br /></td></tr>
<tr class="separator:ga8bd5a797d207c4e04799105c065c46be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72dc3f21af6c125c71221860c5d9fd36"><td class="memItemLeft" align="right" valign="top">void void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga72dc3f21af6c125c71221860c5d9fd36">talloc_named_const</a> (const void *context, size_t size, const char *name)</td></tr>
<tr class="memdesc:ga72dc3f21af6c125c71221860c5d9fd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic routine to allocate a chunk of memory.  <a href="#ga72dc3f21af6c125c71221860c5d9fd36">More...</a><br /></td></tr>
<tr class="separator:ga72dc3f21af6c125c71221860c5d9fd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df9c4bfbb03458a2f22b45e6a69de3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5df9c4bfbb03458a2f22b45e6a69de3a"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>_talloc_zero</b> (const void *ctx, size_t size, const char *name)</td></tr>
<tr class="separator:ga5df9c4bfbb03458a2f22b45e6a69de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854bc4e030677deae1c68d10bb5de31a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga854bc4e030677deae1c68d10bb5de31a">talloc_get_name</a> (const void *ptr)</td></tr>
<tr class="memdesc:ga854bc4e030677deae1c68d10bb5de31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of a talloc chunk.  <a href="#ga854bc4e030677deae1c68d10bb5de31a">More...</a><br /></td></tr>
<tr class="separator:ga854bc4e030677deae1c68d10bb5de31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4f10b2b41c13879fd30cdb30b50862"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga1f4f10b2b41c13879fd30cdb30b50862">talloc_check_name</a> (const void *ptr, const char *name)</td></tr>
<tr class="memdesc:ga1f4f10b2b41c13879fd30cdb30b50862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that a talloc chunk carries a specified name.  <a href="#ga1f4f10b2b41c13879fd30cdb30b50862">More...</a><br /></td></tr>
<tr class="separator:ga1f4f10b2b41c13879fd30cdb30b50862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75452866b0cd5c7d5a3a8e7c9dd7a6a5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga75452866b0cd5c7d5a3a8e7c9dd7a6a5">talloc_parent</a> (const void *ptr)</td></tr>
<tr class="memdesc:ga75452866b0cd5c7d5a3a8e7c9dd7a6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent chunk of a pointer.  <a href="#ga75452866b0cd5c7d5a3a8e7c9dd7a6a5">More...</a><br /></td></tr>
<tr class="separator:ga75452866b0cd5c7d5a3a8e7c9dd7a6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45aec19f076278e5ab25c860951e6ad6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga45aec19f076278e5ab25c860951e6ad6">talloc_parent_name</a> (const void *ptr)</td></tr>
<tr class="memdesc:ga45aec19f076278e5ab25c860951e6ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a talloc chunk's parent name.  <a href="#ga45aec19f076278e5ab25c860951e6ad6">More...</a><br /></td></tr>
<tr class="separator:ga45aec19f076278e5ab25c860951e6ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdaffb5e7b6ec5ee2a2d94070074338"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga7fdaffb5e7b6ec5ee2a2d94070074338">talloc_total_size</a> (const void *ptr)</td></tr>
<tr class="memdesc:ga7fdaffb5e7b6ec5ee2a2d94070074338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of a talloc chunk including its children.  <a href="#ga7fdaffb5e7b6ec5ee2a2d94070074338">More...</a><br /></td></tr>
<tr class="separator:ga7fdaffb5e7b6ec5ee2a2d94070074338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb6eba197e7e2cf57f7f7a5dce21b869"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#gabb6eba197e7e2cf57f7f7a5dce21b869">talloc_total_blocks</a> (const void *ptr)</td></tr>
<tr class="memdesc:gabb6eba197e7e2cf57f7f7a5dce21b869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of talloc chunks hanging off a chunk.  <a href="#gabb6eba197e7e2cf57f7f7a5dce21b869">More...</a><br /></td></tr>
<tr class="separator:gabb6eba197e7e2cf57f7f7a5dce21b869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cc5ecd3f28ea75ea67743426170f7d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0cc5ecd3f28ea75ea67743426170f7d8"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>_talloc_memdup</b> (const void *t, const void *p, size_t size, const char *name)</td></tr>
<tr class="separator:ga0cc5ecd3f28ea75ea67743426170f7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4e82f4d46ccddb27bc1101e10c66b59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac4e82f4d46ccddb27bc1101e10c66b59"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>_talloc_get_type_abort</b> (const void *ptr, const char *name, const char *location)</td></tr>
<tr class="separator:gac4e82f4d46ccddb27bc1101e10c66b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5dee9fd4d8d4700f14ea4dd92cd4f14"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#gaa5dee9fd4d8d4700f14ea4dd92cd4f14">talloc_find_parent_byname</a> (const void *ctx, const char *name)</td></tr>
<tr class="memdesc:gaa5dee9fd4d8d4700f14ea4dd92cd4f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a parent context by name.  <a href="#gaa5dee9fd4d8d4700f14ea4dd92cd4f14">More...</a><br /></td></tr>
<tr class="separator:gaa5dee9fd4d8d4700f14ea4dd92cd4f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454194769421483dbd512f26c622f713"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__talloc.html#ga454194769421483dbd512f26c622f713">talloc_pool</a> (const void *context, size_t size)</td></tr>
<tr class="memdesc:ga454194769421483dbd512f26c622f713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a talloc pool.  <a href="#ga454194769421483dbd512f26c622f713">More...</a><br /></td></tr>
<tr class="separator:ga454194769421483dbd512f26c622f713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77a2717f102c41c6ef4bc2d656c92096"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga77a2717f102c41c6ef4bc2d656c92096"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>_talloc_pooled_object</b> (const void *ctx, size_t type_size, const char *type_name, unsigned num_subobjects, size_t total_subobjects_size)</td></tr>
<tr class="separator:ga77a2717f102c41c6ef4bc2d656c92096"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>talloc is a hierarchical, reference counted memory pool system with destructors. </p>
<p>It is the core memory allocator used in Samba. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga2b3203a43d49423d064e1d889f6c584d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TALLOC_FREE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ctx</td><td>)</td>
          <td>&#160;&#160;&#160;do { talloc_free(ctx); ctx=NULL; } while(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a talloc chunk and NULL out the pointer. </p>
<p><a class="el" href="group__talloc.html#ga2b3203a43d49423d064e1d889f6c584d" title="Free a talloc chunk and NULL out the pointer. ">TALLOC_FREE()</a> frees a pointer and sets it to NULL. Use this if you want immediate feedback (i.e. crash) if you use a pointer after having free'ed it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The chunk to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac7641a167abed37605421833eb5f92a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define talloc_pooled_object</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_ctx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_num_subobjects, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_total_subobjects_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(_type *)_talloc_pooled_object((_ctx), <span class="keyword">sizeof</span>(_type), #_type, \</div>
<div class="line">                    (_num_subobjects), \</div>
<div class="line">                    (_total_subobjects_size))</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga8a521b1347c0e37b84eb942db8fa9beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="group__talloc.html#ga8a521b1347c0e37b84eb942db8fa9beb">TALLOC_CTX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a talloc parent type. </p>
<p>As talloc is a hierarchial memory allocator, every talloc chunk is a potential parent to other talloc chunks. So defining a separate type for a talloc chunk is not strictly necessary. TALLOC_CTX is defined nevertheless, as it provides an indicator for function arguments. You will frequently write code like</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct foo *foo_create(TALLOC_CTX *mem_ctx)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        struct foo *result;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        result = talloc(mem_ctx, struct foo);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        if (result == NULL) return NULL;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;                ... initialize foo ...</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        return result;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
</div><!-- fragment --><p>In this type of allocating functions it is handy to have a general TALLOC_CTX type to indicate which parent to put allocated structures on. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1f4f10b2b41c13879fd30cdb30b50862"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_check_name </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that a talloc chunk carries a specified name. </p>
<p>This function checks if a pointer has the specified name. If it does then the pointer is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The talloc chunk to check.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name to check against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer if the name matches, NULL if it doesn't. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5dee9fd4d8d4700f14ea4dd92cd4f14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_find_parent_byname </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a parent context by name. </p>
<p>Find a parent memory context of the current context that has the given name. This can be very useful in complex programs where it may be difficult to pass all information down to the level you need, but you know the structure you want is a parent of another context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The talloc chunk to start from.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the parent we look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The memory context we are looking for, NULL if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga939926bc6d0d87e1f223a993decb70e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void talloc_free_children </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a talloc chunk's children. </p>
<p>The function walks along the list of all children of a talloc context and talloc_free()s only the children, not the context itself.</p>
<p>A NULL argument is handled as no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The chunk that you want to free the children of (NULL is allowed too) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga854bc4e030677deae1c68d10bb5de31a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* talloc_get_name </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of a talloc chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The talloc chunk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current name for the given talloc pointer.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__talloc.html#ga75097bd7d060a95d42f76cf41bffa207" title="Assign a name to a talloc chunk. ">talloc_set_name()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f4a621ca5763f779d011d88b869bbeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new top level talloc context. </p>
<p>This function creates a zero length named talloc context as a top level context. It is equivalent to:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;talloc_named(NULL, 0, fmt, ...);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string for the name.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Additional printf-style arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated memory chunk, NULL on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__talloc.html#ga8bd5a797d207c4e04799105c065c46be" title="Create a named talloc chunk. ">talloc_named()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bd5a797d207c4e04799105c065c46be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_named </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a named talloc chunk. </p>
<p>The <a class="el" href="group__talloc.html#ga8bd5a797d207c4e04799105c065c46be" title="Create a named talloc chunk. ">talloc_named()</a> function creates a named talloc pointer. It is equivalent to:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ptr = talloc_size(context, size);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;talloc_set_name(ptr, fmt, ....);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The talloc context to hang the result off.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of char's that you want to allocate.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string for the name.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Additional printf-style arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated memory chunk, NULL on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__talloc.html#ga75097bd7d060a95d42f76cf41bffa207" title="Assign a name to a talloc chunk. ">talloc_set_name()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga72dc3f21af6c125c71221860c5d9fd36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void* talloc_named_const </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic routine to allocate a chunk of memory. </p>
<p>This is equivalent to:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ptr = talloc_size(context, size);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;talloc_set_name_const(ptr, name);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The parent context.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of char's that we want to allocate.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name the talloc block has.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated memory chunk, NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75452866b0cd5c7d5a3a8e7c9dd7a6a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_parent </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parent chunk of a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The talloc pointer to inspect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The talloc parent of ptr, NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45aec19f076278e5ab25c860951e6ad6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* talloc_parent_name </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a talloc chunk's parent name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The talloc pointer to inspect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of ptr's parent chunk. </dd></dl>

</div>
</div>
<a class="anchor" id="ga454194769421483dbd512f26c622f713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* talloc_pool </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a talloc pool. </p>
<p>A talloc pool is a pure optimization for specific situations. In the release process for Samba 3.2 we found out that we had become considerably slower than Samba 3.0 was. Profiling showed that malloc(3) was a large CPU consumer in benchmarks. For Samba 3.2 we have internally converted many static buffers to dynamically allocated ones, so malloc(3) being beaten more was no surprise. But it made us slower.</p>
<p><a class="el" href="group__talloc.html#ga454194769421483dbd512f26c622f713" title="Allocate a talloc pool. ">talloc_pool()</a> is an optimization to call malloc(3) a lot less for the use pattern Samba has: The SMB protocol is mainly a request/response protocol where we have to allocate a certain amount of memory per request and free that after the SMB reply is sent to the client.</p>
<p><a class="el" href="group__talloc.html#ga454194769421483dbd512f26c622f713" title="Allocate a talloc pool. ">talloc_pool()</a> creates a talloc chunk that you can use as a talloc parent exactly as you would use any other <a class="el" href="group__talloc.html#ga8a521b1347c0e37b84eb942db8fa9beb" title="Define a talloc parent type. ">TALLOC_CTX</a>. The difference is that when you talloc a child of this pool, no malloc(3) is done. Instead, talloc just increments a pointer inside the talloc_pool. This also works recursively. If you use the child of the talloc pool as a parent for grand-children, their memory is also taken from the talloc pool.</p>
<p>If there is not enough memory in the pool to allocate the new child, it will create a new talloc chunk as if the parent was a normal talloc context.</p>
<p>If you talloc_free() children of a talloc pool, the memory is not given back to the system. Instead, free(3) is only called if the <a class="el" href="group__talloc.html#ga454194769421483dbd512f26c622f713" title="Allocate a talloc pool. ">talloc_pool()</a> itself is released with talloc_free().</p>
<p>The downside of a talloc pool is that if you talloc_move() a child of a talloc pool to a talloc parent outside the pool, the whole pool memory is not free(3)'ed until that moved chunk is also talloc_free()ed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The talloc context to hang the result off.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the talloc pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated talloc pool, NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75097bd7d060a95d42f76cf41bffa207"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* talloc_set_name </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a name to a talloc chunk. </p>
<p>Each talloc pointer has a "name". The name is used principally for debugging purposes, although it is also possible to set and get the name on a pointer in as a way of "marking" pointers in your code.</p>
<p>The main use for names on pointer is for "talloc reports". See <a class="el" href="group__talloc__debug.html#ga4f4ff95ce5a95f61cc453fc943e3de65" title="Print a summary report of all memory used by ptr. ">talloc_report()</a> and <a class="el" href="group__talloc__debug.html#ga66136eb6105416bfcbd390ce6a4fc89c" title="Print a summary report of all memory used by ptr. ">talloc_report_full()</a> for details. Also see <a class="el" href="group__talloc__debug.html#gac6f0c065b4ed391acb5c74240a8647bc" title="Enable leak report when a program exits. ">talloc_enable_leak_report()</a> and <a class="el" href="group__talloc__debug.html#gab01ab00014902d25e9eaba9fd172821c" title="Enable full leak report when a program exits. ">talloc_enable_leak_report_full()</a>.</p>
<p>The <a class="el" href="group__talloc.html#ga75097bd7d060a95d42f76cf41bffa207" title="Assign a name to a talloc chunk. ">talloc_set_name()</a> function allocates memory as a child of the pointer. It is logically equivalent to:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;talloc_set_name_const(ptr, talloc_asprintf(ptr, fmt, ...));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The talloc chunk to assign a name to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string for the name.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Add printf-style additional arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assigned name, NULL on error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Multiple calls to <a class="el" href="group__talloc.html#ga75097bd7d060a95d42f76cf41bffa207" title="Assign a name to a talloc chunk. ">talloc_set_name()</a> will allocate more memory without releasing the name. All of the memory is released when the ptr is freed using talloc_free(). </dd></dl>

</div>
</div>
<a class="anchor" id="ga204ed205d6b1524c46f12541d5eca686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void talloc_set_name_const </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a name to a talloc chunk. </p>
<p>The function is just like <a class="el" href="group__talloc.html#ga75097bd7d060a95d42f76cf41bffa207" title="Assign a name to a talloc chunk. ">talloc_set_name()</a>, but it takes a string constant, and is much faster. It is extensively used by the "auto naming" macros, such as talloc_p().</p>
<p>This function does not allocate any memory. It just copies the supplied pointer into the internal representation of the talloc ptr. This means you must not pass a name pointer to memory that will disappear before the ptr is freed with talloc_free().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The talloc chunk to assign a name to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Format string for the name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabb6eba197e7e2cf57f7f7a5dce21b869"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t talloc_total_blocks </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of talloc chunks hanging off a chunk. </p>
<p>The <a class="el" href="group__talloc.html#gabb6eba197e7e2cf57f7f7a5dce21b869" title="Get the number of talloc chunks hanging off a chunk. ">talloc_total_blocks()</a> function returns the total memory block count used by this pointer and all child pointers. Mostly useful for debugging.</p>
<p>Passing NULL is allowed, but it will only give a meaningful result if <a class="el" href="group__talloc__debug.html#gac6f0c065b4ed391acb5c74240a8647bc" title="Enable leak report when a program exits. ">talloc_enable_leak_report()</a> or <a class="el" href="group__talloc__debug.html#gab01ab00014902d25e9eaba9fd172821c" title="Enable full leak report when a program exits. ">talloc_enable_leak_report_full()</a> has been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The talloc chunk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total size. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fdaffb5e7b6ec5ee2a2d94070074338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t talloc_total_size </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size of a talloc chunk including its children. </p>
<p>The function returns the total size in bytes used by this pointer and all child pointers. Mostly useful for debugging.</p>
<p>Passing NULL is allowed, but it will only give a meaningful result if <a class="el" href="group__talloc__debug.html#gac6f0c065b4ed391acb5c74240a8647bc" title="Enable leak report when a program exits. ">talloc_enable_leak_report()</a> or <a class="el" href="group__talloc__debug.html#gab01ab00014902d25e9eaba9fd172821c" title="Enable full leak report when a program exits. ">talloc_enable_leak_report_full()</a> has been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The talloc chunk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total size. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
